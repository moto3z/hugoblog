---
title: "20240529 Sp준비"
date: 2024-05-29T14:24:01+09:00
draft: true
---

# SP 준비 - 게시하지 않는 글

## RDBMS

- 슬로우/더티쿼리 : 느린쿼리, 예를들어서 테이블 풀스캔이 나는 쿼리, 라이크 쿼리에 키워드 앞뒤로 % 가 붙는 쿼리를 의미합니다
- 악성쿼리 : 클라이언트가 입력한 데이터를 서버에서 필터링, 이스케이핑을 해야함, 에러페이지를 표시하지 않고, 서버검증을 꼭 한다. (SQLi)
- ER-D 란? 엔티티 릴레이션 다이어그램, 데이터를 모델링한것인데, 시스템, 비지니스 프로세스 에 사용되는 데이터들과 그 관계들에 대해서 표현
- 데이터베이스 설계 원칙
  - 정규화란 RDBMS 에서 데이터를 중복없이 저장하기 위한 프로세스
  - 1정규화 : 한칸에는 데이터 하나만
  - 2정규화 : 현제 테이블의 주제와는 관련없는 컬럼을 다른 테이블로 빼는 작업(파셜 디펜던시의 제거)
  - 3정규화 : 특정 컬럼에 종속된 컬럼은 다른 테이블로 분리해내기
- 아이솔레이션 레벨
  - READ UNCOMMITTED : 커밋이나 롤백에 상관없이 다른 트랜잭션에서 데이터가 보임, 정합성 문제가 있을수 있음 (표준 격리수준아님!)
  - READ UNCOMMITTED : 변경 내용이 COMMIT 되어야만 다른 트랜잭션에서 조회 가능, NON-REPETABLE READ 문제 발생 (다른 트랜잭션 입장에서, 데이터를 똑같은걸 두번 조회했는데 다른 결과가 발생할 수 있다는것)
  - REPETABLE READ : 같은 트랜잭션 내에서는 같은 값이 조회되도록 보장해주는 격리수준, Phantom READ 문제가 있음 (같은 쿼리를 두번 조회했는데, 처음에는 없던 레코드가 두번쨰에서 나타나는 증상)
- 데이터베이스 락(비관적pessimistic / 낙관적optimistic )
  - pessimistic lock : 충돌이 일어난다고 가정하고 락을 거는 방식, 트랜잭션이 시작될 때 Shared Lock 또는 Exclusive Lock을 걸고 시작해서 데이터 충돌을 예방하는 방식.
  - JPA 에서 LockModeType 옵션이 있음, 비관적락은 데드락 발생가능성이 있고 동시처리 성능이 저하된다. 낙관적 락은 충돌

- acid 원칙 : 트랜잭션을 정의하는 4가지 원칙입니다. Atomicity(원자성), Consistency(일관성), Isolation(격리성), Durability(영속성)
- 인덱스 : 테이블에서 write 성능을 희생하고 read 성능을 높이는 자료구조이며, b-tree 알고리즘을 사용합니다.
- 클러스터드 인덱스 : MySQL의 innoDB 엔진에서는 primary key 순서로 레코드들이 물리적으로 정렬되어서 저장되어 있는데, 이를 클러스터드 인덱스라고 합니다
- (RDB) 카디널리티 : Cardinality 는 특정 데이터 집합의 유니크(Unique)한 값의 개수, 중복도의 반대되는 개념
  - 1,1,1,1,1 : 카디널리티는 낮고, 중복도는 높다
  - 1,2,3,4,5 : 카디널리티는 높고, 중복도는 낮다
- (RDB) 복합키 인덱스에서, 복합키 인덱스의 순서
  - 카디널리틱다 큰 순서대로 (유니크한게 많은 컬럼이 먼저!)
- 데이터베이스 성능최적화란? : RDBMS 최적화는 한마디로 Disk FILE I/O 를 최대한 줄이는것이다.
  - 커버링인덱스로 메모리의 인덱스만 가지고 쿼리를 충족한다던지
  - 카디널리티가 높은 컬럼에 인덱스를 태워서 필요한 데이터만 가져온다던지
- 커버링인덱스 : 쿼리를 수행하는데 필요한 모든 데이터가 메모리상의 인덱스에 존재해서, 파일IO로 접근해야하는 리프노드에 접근하지 않고도 쿼리결과를 리턴할수 있는 경우가 커버링인덱스
- 복합 인덱스란 : 데이터베이스에서 여러 개의 컬럼(열)들을 조합하여 인덱스를 생성하는 것
- 복합인덱스 순서 : 카디널리티가 큰 (=중복도가 낮은) 순서대로 구성하기

## JPA

- 엔티티 라이프사이클 : 비영속(객체생성만) - 영속(저장, 트랜잭션 커밋시점) - 준영속(컨텍스트 detach) - 삭제
- 영속성 컨텍스트: 엔티티를 영구 저장하는 환경인데, 트랜잭션마다 하나씩 생기
- 1차캐시 : 영속성 컨텍스트 내부에 엔티티를 보관하는 저장소가 있는데 이것을 1차캐시라고 하고 영속성 컨텍스트 내부 범위에서의 캐시
- 2차캐시 : 어플리케이선 레벨의 캐시, 레디스같은 외부 저장소를 쓸수도 있는데 어플리케이션 범위의 JPA 캐시가 2차캐시임. 기본은 사용안함
  - JPA 쿼리시 1차캐쉬 찾아보고 - 2차캐시 찾아보고 - 없으면 그때 RDBMS에 Select~ 날림
- 영속성 컨텍스트의 기능 (5가지)
  - 1차캐시, 동일성 보장, 트랜잭션쓰기지연, 더티체킹, 레이지 로딩
- 트랜잭션은 어떻게 구현하나요?
  - AOP 기반으로 프록시객체를 이용해서 StartTX / commit or rollback 을 메인로직 앞뒤로 끼워넣어서 동작합니다
- @Transactional 사용시 주의사항
  - 1. private method 에 사용할 수 없음
  - 2. 서로 다른 @Transactional method 는 서로를 호출해서 사용할 수 없음
- N+1 문제가
- ORM이란? 오브젝트 릴레이션 맵핑의 약자로써 자바의 객체와 RDBMS 의 레코드 하나를 매핑 해주는 기술입니다.
- (JPA) OSIV : JPA 에서 영속성 컨텍스트를 뷰까지 열어두는 기능. 쉽게말해서 트랜잭션이 service, repo layer 에만 있는거 아니라, controller 레이어까지 걸쳐 있다 기본값으로 ON (Open Session In View)
  - 장점은 , B2B 서비스에서 좋은데, 사용자가 적은 환경에서는 영속성 컨텍스트가 빠르게 열리고 불필요한 영.컨의 open/close 가 적기때문에 성능이나 응답속도가 개선된다
  - 단점은 , B2C 서비스에서 안좋은데, 사용자가 많으면 영속성컨텍스트가 열리는게 DB 커넥션풀을 하나 여는것이기 때문에 사용자가 많은 배민같은 서비스에서 osiv on 하면 커넥션풀이 말라버리기 때문에(커넥션이 부족해져서) 사용자가 많은 서비스는 서비스는 적용하기 어렵다



## Spring Framework

- 스프링에 대해서 이야기해주세요 : 자바기반의 OOP 웹 프레임워크입니다. 핵심기술로는 DI, 벨리데이션과 바인딩, 데이터 엑세스와 트랜잭선, AOP 등의 기능이 있습니다.
- 커넥션 풀 갯수는 어떻게 최적화 하나요? : 쓰래드풀 수 _ 쓰레드당 필요한 커넥션 수 _ 배수 (디폴트 10, 맥스 200 으로 알고있습니다). 자바에서는 히카리CP 를 기본 데이터소스로 사용중임
- 쓰레드 풀 숫자는 어떻게 최적화 하나요? : CPU 코어 갯수 \* 2 정도로 지정하는게 좋을꺼같습니다.
- SOLID 원칙이란 : 객체 지향 디자인 원칙, 유지보수하기 좋고 유연하게 확장 가능한 소프트웨어를 만들기 위해서 필요합니다. SRP, OCP, LSP, ISP, DIP
- DI : 객채간 의존성을, 내부에서 직접 생성자를 호출하지 않고, 외부에서 주입받는 디자인 패턴입니다.
  - 외부에서 객체간 관계 설정시, 클래스 레벨의 의존이 아니라 인터페이스 레벨로 의존하여서 메시지를 주고받음으로써 계층간 결합을 느슨하게 합니다.
- AOP : 스프링 프레임워크의 기능 중 하나로, 핵심 비즈니스 로직과 부가 기능(횡단 관심사, cross-cutting concerns)을 분리하여 모듈화할 수 있게 해줍니다
- 필터, 인터셉터, AOP 차이점 : 셋 모두 소프트웨어에서 횡단관심사(크로스컷)을 처리하기 위한 방식인데요, 목적과 사용방식에 차이가 있습니다.
  - 필터는 HTTP 요청과 응답을 주고받는데 사용되며, CORS 토큰처리 등에 사용됩니다
  - 인터셉터는 프레임워크 기능, AOP 는 핵심로직이 아닌 부가적인 로직(로깅추가, 예외처리, 트랜잭션 롤백) 등의 횡단 관심사를 모듈화하는데 사용
  - 인터셉터는 HTTP 요청과 응답을 가로채기 위해 사용되며 특정 URL 패턴에 대한 요청을 처리하기 전에 전처리 작업을 수행하거나, 후처리 작업을 수행합니다.
  - Spring MVC에서 HandlerInterceptor 인터페이스를 구현하여 사용
- AOP 는 핵심 비즈니스 로직과는 별도로 관심사(횡단 관심사, Cross-cutting Concerns)를 분리하여 모듈화하는 데 사용
  - Aspect, Advice, Join Point, Pointcut 등의 개념을 사용하여 동작하고 Before, After, Around 등에 코드 실행
- REST API 란 웹 서비스를위한 소프트웨어 아키텍쳐 스타일 "어떻게 http프로토콜로 정보를 제공할 것인가 에 대한 답"
  - self-decriptive : 메시지는 스스로 설명해야한다 헤더와 바디 모두
  - hateoas : app 의 상태는 하이퍼링크를 이용해 전이되어야한다
  - indiviual-evolution : 프론트와 백엔드, 웹브라우저 모두 독립적으로 진화 가능해야 한다


## Kotlin 
- 코루틴이란 : 일반 함수 호출과 달리 자신이 호출을 양보(yield)하고, 다시 재개(resume)될 수 있는 함수, 명시적으로 제어권을 양보
- 고루틴은 Go 런타임에 의해 관리되는 선점형 경량 스레드로 많은 동시 작업을 처리하는 데 유리

## JVM & 자바
- 제네릭 : 클래스, 인터페이스 및 메서드에서 사용할 데이터 타입을 미리 지정하지 않고, 나중에 코드가 실행될 때 구체적인 타입을 지정할 수 있게 하는 기능, 타입검사를 컴파일타임에 모두 처리하여 런타임 에러를 미리 잡아낼수 있는 기능
- 자바jit
- GC 옵션
- 어트리뷰트

## Go Lang
- goroutine과 채널(channels)에 대해 설명해 주세요.
  - goroutine은 Go의 경량 스레드로, go 키워드를 사용해 생성합니다. 
  - 채널은 goroutine 간의 통신을 위한 구조로, chan 키워드를 사용해 선언

- defer 키워드의 용도
  - defer 키워드는 함수가 종료될 때 실행될 코드 블록을 지정하는 데 사용됩니다. 주로 리소스 해제, 파일 닫기 등의 작업에 사용

- Go에서 인터페이스
  - 인터페이스는 메서드의 집합을 정의
  - 특정 타입이 인터페이스를 구현하는지 여부는 명시적으로 선언할 필요 없이 해당 메서드를 구현하는지로 결정합니다. 이를 덕타이핑

- 고루틴 구조, GC구조, 프로파일링, 덕타이핑

- Go는 컴파일 기반 정적 Type 언어이다. 하지만 동적 언어의 특성이 존재하며 덕타이핑 방식으로 작동하는 Go의 Interface가 있고  Compile time 에 결정됨

- Go에서의 에러 처리 방법을 설명해 주세요.
  - Go는 예외 처리를 지원하지 않으며, 대신 명시적인 에러 반환을 사용

- 고랭 Gin 프레임워크 사용, 미들웨어, SQLC, 

## 고랭과 자바 차이점
- 인터페이스를 구현할때 : 인터페이스 구현을 명시하느냐, 덕타이핑으로 암시하느냐
- 에러핸들링에서 Java 는 Throw 하는데 go 는 에러를 반환함
- 고랭 testify에서 require 모듈 써야함

## JS, Vue, React



## K8S


## ElasticSearch
- 인버티드 인덱스 (es) : 어떤 내용과 그것의 위치를 매핑한 자료구조로 해시맵과 비슷하다. 가령 '맛집'이라는 단어가 포함된 문서/웹페이지의 위치를 알려주는 것 // 인덱스는 번호 위치가 있으면 거기에 있는 데이터가 뭔지를 빨리 알려주는건데, 그 반대라서 인버티드 인덱스


## Hadoop (kafka, spark, airflow)
- 카프카 : 메시지 브로커, 빠른 쓰기속도를 가지고 있다. 생산자-소비자 패턴의 대표적인 사례

### 와일드카드

- 어떤 방식으로 협업하시나요?
  - 짧은주기로 자주 소통합니다.
  - 업무에 방해가 되지 않도록 async 방식으로 주로 소통합니다
  - 하는일의 목적의식을 가지고 일하면서 적극적으로 의견을 구하고 피드백을 받습니다.
- 앞으로 뭘 하고싶으신가요?
  - 누군가가 정말 필요로하는, 세상에 도움이 되면서 동시에 회사에 영업이익을 플러스 시켜줄수 있는 프로젝트에 참여하고싶습니다.
  - 프로젝트를 서비스/프로덕트로 만들어 실제로 동작하게 만드는 과정 속에서 스스로의 노력 과 동료들과의 협업 그리고 피드백을 통해서 기술적으로도 한단계 성장하지만, 인간적으로도 한단계 성장하고 싶습니다
  - 더 욕심을 내보자면 주도적으로 이슈를 해결하고, 발굴해내고, 제가 아는것을 공유하고 모르는것을 인정하고 받아들이면서 동료들에게 영감과 용기를 주는 사람이 된다면 정말 영광일꺼같습니다.
- 조직에 어떤것을 기대하시나요?
  - 기술적 : 중요한 비지니스 로직을 단위테스트로 검증할수 있는 구조, 테스트코드, 코드리뷰 문화, 빠르게 요구사항을 수용할수 있는 지속가능한 코드
  - 협업과 커뮤니케이션 문화 : 자유로운 의견 교환, 건설적인 피드백, 목적의식 있는 업무진행

- 질문
  - 팀에서 협업과 커뮤니케이션은 어떤 방식으로 이루어지나요?
  - 20명 정도의 팀을 리딩하시면서, 개개인의 역량이나 성과를 어떻게 파악하고 어떤 기준으로 평가하시는지 궁금합니다
  - 프로젝트를 진행하면서 어떻게 일정을 관리하시는지, 일정지연이나 이슈에는 어떻게 대응하시는지, 업무 우선순위는 어떻게 결정하시는지 궁금합니다

## RNR 정리

- 10X를 추구합니다 : 혼자 잘하기보다 다같이 일을 잘 할수 있도록 노력하는 사람

  - 불필요한 코드를 지우는사람
  - 데이터 구조를 코드로 관리하는사람
  - 도메인 지식을 문서로 남기고 코드로 녹이기 위해 노력하는사람
  - 문서로 아는것을 나누기 위해 노력하는 사람
  - 구조적인 개선을 위해 노력하는 사람 $N^2$ -> $nLogN$ 으로 바꾸기 위해 노력하는사람

- 꿀팁 $~~$ : 레이텍스 >> 달러두개는 한줄,

> > 인조잔디인지, 천연잔디인지 << 인조잔디가 하도 많아서

- 공개소스나, 깃헙레포가 있는지


### 셀프리뷰
- Strengths
  - 다양한 분야에 vertical :
    - Laas부문의 프로덕션을 만들어가는데 혈액과 같은 역할로써 필요한 순간에 필요한 역할을 해왔음
    - 기술전문성 : kotlin, java, spring framework 지식, 이해 그리고 활용 역량을 갖추기 위해 지속적으로 노력해 왔습니다.
    - 문제해결능력 : 비즈니스 문제를 코드로 풀어내는 능력을 보유하고 있습니다. 
    - 팀 협업 : 팀원들과의 원활한 커뮤니케이션과 협업을 통해 프로젝트를 성공적으로 이끌어내는 능력

- Weaknesses
  - 멀티테스킹 & 업무우선순위파악 : 솔루션 프로젝트, 프로덕트 보완 등 여러가지 Phase 에서 중첩되어 들어오는 상황에서의 우선순위를 조금 더 잘 파악하고 해결해나가고싶습니다.
  - 도메인 지식 : 물류 도메인 지식의 부족, 검색도메인 지식 부족

- Opportunities
  - 적절한 퀄리티와 적절한 시간 내에 업무를 완성하기 :  기능을 sure하게, 출시를 speedy하게, 제품을 safety 하게, 인프라 비용을 Low 하게
  - 디지털 컨버전스 가속화 : 아날로그로 처리되는 전통산업에 가치를 더하고 비즈니스 혁신을 이뤄낼 수 있는 디지털 컨버전스의 대항해 시대입니다.

- Threats
  - 앞으로 주어진 혹은 조직에서 필요한 업무들을 주도적으로 발굴해서 해결하고 싶습니다.
  - 인공지능이 뉴노멀이 되고 범용 컴퓨터만큼 널리 사용하는 특이점이 멀지 않았다고 생각하는데요, 여기에 대한 대응이 조금은 뒤쳐져있다고 생각합니다.

## 썰 준비

- 실용주의 : 문제를 해결하는 가장 간단하고 실용적인 방법을 사용해 구현하기 위해 노력합니다. 실용적인 테스트코드를 작성하고, 개발한 기능들을 자동화된 코드로 테스트할수 있는 역량

- 단위테스트 : 코드에 녹아있는 비지니스를 분리하는 리팩토링과 이를 검증하는 단위 테스트를 작성할 수 있는 역량

- 아키텍쳐 : 검증가능하고 합리적인 수준에서 확장가능하게 설계하는 능력

- 마음 : 프로젝트 성공과 프로덕트 완성에 있어 코드나 기능 구현뿐만 아니라 사람의 마음도 중요하다는것을 알고 실천하기

- 메타인지 : 지금보다 더 합리적인 대안이 있고 모른것을 인정할수 있는 메타인지와 용기

- 전환력&피드백 수용 : 아는만큼 보이고 모르는것이 많다는 생각을 가지고 있어 피드백을 수용하고 빠르게 전환할수 있는 전환력을 갖추고 있습니다.

- 경청하기 : 타인의 의견을 잘 듣고 의도를 파악하려는 의식적인 노력

- 조금더 근본적인것을 학습하고 체득하기 위해 노력합니다 OOP, 검증가능하고 지속가능한 코드, 테스트코드, 리팩토링, 아키텍쳐,

- wms 는 바운디드 컨텍스트가 4개가 있습니다 : 입고, 출고, 프로덕트(SKU), 로케이션



<br><br><br><br><br>



## 한일들 - 솔루션

- Wonderland OMS 프로젝트

  - OMS 개발지원
    - 사례1 : 간헐적인 HTTP 500 error 트러블슈팅 > skillbuilder 저장용량 & 메모리 부족이슈 원인 파악하여 용량증설
    - 사례2 : JenkinsBatch 에서 Spring-Domain LOG 가 보이지 않는 이슈 해결 : logback config 수정
    - 사례3 : 관계형데이터베이스 DDL, DML 버전 관리
    - 사례4 : 공통-OMS 마스터 데이터 연동 SAGA 개발 : Grpc, Kafka 사용
  - 성능테스트
    - 서버 리소스 (pod Count, Memory Size) 에 따른 성능 변화 확인
    - pod count 가 2,4,6,8 변함에 따라 성능에 어떤 영향을 미치는지 확인한 결과 pod 수는 4개로 충분함을 확인함
    - MySQL Spec 에 따른 성능 변화 확인 & 목표 TPS 달성을 위한 인프라 스펙 산출 DB Spec Class(cpu+memory) 변화에 따른 성능을 산출하고 목표 TPS 도달을 위한 필요스팩을 "데이터 기반으로 추세선을 파악하여 산출함"
  - 도메인 용어집 정리, OMS flow chart 정리 : DO, STO, TO, EO
  - 코드관리, git & branch 관리, conflict 해결

- Apollo OMS 프로젝트
  - 성능테스트
    - OMS 시스템에 대한 성능테스트를 진행
      - 시나리오에 따른 대상과 범위인 target API Endpoint 정리
      - 성능테스트 환경 구성 (by ngrinder) & script (groovy) 작성
      - API Endpoint 에 대한 RPS(Request Per Second) 를 산출하였습니다.
        - TODO : 정리하기 ngrinder 환경구성 & 샘플 스크립트 작성하는거 진행해야함
    - 성능테스트 보고서 등의 산출물을 공유하고 결과보고서 작성
    - tech stack : grafana(RDB, Backend 모니터링), nGrinder 사용
  - 아모레퍼시픽 프로젝트 성능테스트 진행
    - 주요 11개 API Endpoint (주문, 운송장, 실적 관련) 에 대한 성능테스트 진행
    - 성능테스트를위한 groovy script 작성, 성능테스트 실시, 성능테스트를 위한 전처리작업 (dataset정제, domain 조건) 진행
    - parameter를 변경하며 최적의 성능지점 확인, RDBMS Spec 변화, Pod 스펙 변화를 통해서 scale-up/scale-out 시 성능 변화 예측 insight
    - Http Request body 변인통제를 통한 최대 throughput 조건 도출
      - OMS 개발지원
    - SAGA 마스터연동 : HTTP, KAFKA

## 한일들 - 플랫폼

- 개인정보 보안로그

  - what : 개인정보 API 호출 History Logging 개발API
    - 접근에 대한 호출자 정보, 응답 개인정보 내용등을 저장
      - 호출자의 정보 : 이메일, LDAP 등..
      - 응답 개인정보 : row count, API endpoint, LogType 자동결정 기능
    - Log 에러방지기능, 필요이상으로 긴 data 들에 대한 validation 기능(email, IP주소 길이 제한)
  - why : 개인정보 보안 법령에 의거한 필수내용 & 사내 ISMS 인증을 위한 개인정보관리 거버넌스 달성
  - how : Spring AOP 기능을 이용해, CrossCut Point 분리하는 구조로 개발함. 이로 인해 Main 로직 변경점 없음으로 유지보수성과 가독성이 좋음

- LaasIAM 서비스 런칭

  - what : okta-auth0 IAM 서비스 런칭
    - auth0 IAM 사용 신규 cbt 클러스터 구축 (k8s, DB Mig 작업진행)
    - IAM 내 계정정보 OM/WM Sync Batch 개발
  - why : 사용하던 kep-iam 서비스 종료로 인한 대체 서비스 Migration

- 이외

  - 프리랜서 입사 & 퇴사 시스템 연결 : Access, git 이슈 해결
  - 보안검수 : 오픈리다이렉트 취약점, CORS, SSL-Offloading, SpringBoot & Vue2 취약점 버전업 대응
  - admin Frontend 유지보수 : VDI ON/OFF 기능 추가하여 개인정보관리 거버넌스 충족
  - 데이터 추출 (마케팅용, 회원관리용, 기획&Biz용 등등..)
  - multiversion in cluster : 한 클러스터 내 여러가지 버전의 OMS를 동작시키고 테스트 할 수 있는 기능 개발
    - OMS가 거대한 3개의 프로젝트(물류대행, 라스트마일, 솔루션프로젝트) 를 동시에 진행하여 테스트가 곤란한 문제를 해결
  - 인턴십 직원 Care 업무
    - Action Item List 기획, 실행, 중간점검 진행
      [Phase1] 로컬개발환경 문서화 (2주 : 04.13 ~ 04.25)
      [Phase2] API Docs (2주 : 04.25 ~ 05.10)
      [Phase3] 마스터 이행 구조도 (4주 05.11 ~ 06.08)
    - 면접 질문지 리스트업, 온보딩, 커피챗 진행
  - Dolphin 물류비 정산 관련 이슈 트러블슈팅
    - bulkinsert 관련 기능개발, 테스트코드 추가
  - OMS 개발지원
    - OMS App 공통백엔드 API
    - SKU 코드 최대길이 제한 변경 20->50
  - SpringBoot App 설정파일 k8s ConfigMap 이관 POC
  - LMD 모듈 화주사 Sync Saga 개발

- 신규 프로젝트 세팅
  - parrotfish 모듈 Gradle spring multimodule 셋팅
    - spring boot 버전 업그레이드 (2.3 -> 2.7)
  - prawn 모듈 Gradle spring multimodule 셋팅
    - JPA + Mybatis 동시사용
  - JDK & JVM Options 정비 & 일원화
  - KIC VM proxy 설정 일원화
  - Springboot 취약점 발견 버전업







## 1분 자기소개


## 지원동기


## 라스나와서 검색오는 이유



## 도커가 뭐죠
- 컨테이너 기반 가상화 플랫폼
- 컨테이너는 소프트웨어 동작을 필요한 라이브러리, 시스템도구, 코드 런타임 등이 포함되어있습니다.
## 도커 왜쓰는거죠?
- 특정 웹서비스를 패키징하고 배포하는데 사용합니다

## 쿠버네티스가 뭐죠
- 컨테이너 오케스트레이션 도구
- 여러대의 머신에 (컴퓨팅 리소스들) 컨테이너화된 어플리케이션을 관리하고 배포하는 툴

## 쿠버네티스를 왜 쓰는거죠?
- 컴퓨팅 리소스 관리
- 컨테이너 기반의 App 들을 배포하기 위해서
- 이외 복구, 로드벨런싱, 
- 노드(머신한대), 포드(앱하나), 서비스(포드 네트워크 접근방식), 디플로이먼트 (APP 배포와 업데이트), 컨피그맵 시크

## 쿠버네티스 실무경험



## 하둡이 뭐죠
- 클러스터링 기반 분산처리 프레임워크 입니다!
(더그커팅이 검색엔진 개발하다가 만든 툴)
(구글 GFS, MapReduce 논문 참고해서 구현)

## 하둡 구성요소는 뭐가 있죠?
- HDFS(하둡 분산FS),YARN(자원, 스케쥴 관리), Mapreduce (데이터병렬처리), 

## 하둡사용경험
- 삼성전자 디바이스 VOC 관리시스템 만드는데 필터는 기기 정보 시리얼, 펌웨어정보, 글로벌 데이터베이스 구축, 영어기준으로 번역해서 만듬
- 실시간 챗봇 데이터로 학습 되어야하고 다른 후방시스템들이랑 연계되어야함.
- 유럽 북미지역은 상담내역 개인정보 파기 요청하면 삭제해야하는데 삭제하는데 기본 탐색을 하면 데이터 하나 삭제하는데 300년 걸린다는 계산이 있었어서 문제 >> 데이터의 저장위를 모두 저장하는 별도의 인덱스를 생성해서 문제 해결 

## 맵리듀스란?
- 프로그래밍 모델로, 대규모 데이터셋을 병렬처리하고 생성하는 프로그래밍 모델 = 맵 + 리듀스
- 맵 : 데이터셋을 청크로 분할하고, 청크별로 K-V 집합만들기
- 리듀스 : 키 기준으로 정렬되고 그룹화된다음, 리스트로 받아 비지니스 로직을 돌립니다.

## 하둡 왜 쓰는거죠?
- 맵리듀스로 배치 프로세싱을 위해서 사용합니다.

## 스파크가 뭐죠? 왜쓰는거죠?
- 인메모리 기반 데이터 처리, 맵리듀스 대비 빠르다.
- 맵리듀스는 중간중간 결과를 디스크에 쓰기때문에 IO부하가 있고, 스파크는 메모리에 중간저장하기떄문에 반복작업 처리효율이 좋습니다.

## HBASE 가 뭐죠 왜쓰는거죠?
- 컬럼(열) 기반 NOSQL 데이터베이스 

## HBASE 랑 MYSQL 차이
- HBASE : 컬럼기반 DBMS : 같은 컬럼끼리 데이터를 묶어서 저장. 컬럼별로 파일이 생성되고 디스크 페이지에 동일한 컬럼값이 연속적으로 저장됨. / 동일컬럼 대량작업에 효율적임 (통계 등,..) 분석용 DB 사용

- MYSQL : 로우기반 DBMS 레코드끼리(엔티티 하나)끼리 뭉쳐서 저장됨, 레코드 단위 CRUD 적합 주로 OLTP 서비스 사

## 스트리밍이란 뭔가요? 
- 데이터가 지속적으로 입력될떄, 실시간으로 처리하는 데이터 처리 방식, 금융거래모니터링, 실시간로그분석
- 배치(batch) 처리와는 다른점이, 시스템 도착 즉시 데이터를 처리하는 방
- 스트림과 배치를 구분 : 데이터의 범위가 고정되어 있는지 (bounded), 고정되어 있지 않은지 (unbounded) 
- 스트림 처리 프레임워크
  - 플링크, 카프카스트림즈, 스파크스트리밍 이 약간의 차이 레이턴시, 값을 한번만 읽을수 있거나 최소한번만 읽게 세팅하거나 등의 차이

## 인덱스란 : 데이터를 빠르게 검색하기 위한 자료구조, 주소를 넣으면 데이터가 나오는 모델을 인덱스라고 합니다

## 역인덱스 : 토큰(데이터조각) 을 넣으면 데이터가 위치하는 주소가 나오는 모델을 역인덱스라고 합니다
- 풀텍스트스캔 검색엔진이 대표적, 키워드를 넣으면 해당 키워드가 위치하는 문서를 빠르게 찾을수 있다.

## Apache Flink 가 뭔가요?
- 스트리밍 데이터 처리(프로세싱) 프레임워크, 배치 처리도 가능
- 이벤트 시간 기반 처리, 네이티브 스트리밍 처리
- UCLOG 붙일때 카프카 뒷단에 붙어서 로그프로세싱 하실려나보다 했습니다.

## 정리
- 하둡맵리듀스 : 디스크 배치프로세싱
- 스파크 : 인메모리 배치프로세싱
- 플링크 : 스트리밍 프로세싱
- 배치와 스트리밍 차이 : 데이터범위가 고정되어있다 아니다 (바운디드 언바운디ㄷ)

## Apache Spark Streaming
- 아파치 스파크의 스트리밍 처리 컴포넌트, 마이크로배치(micro-batch) 방식을 사용
- 스파크 스트리밍은 마이크로배치


## es 에서 검색할때 term 이랑 match 차이가 뭐니

1. term 쿼리
term 쿼리는 정확한 값을 찾기 위해 사용됩니다. 이는 구조화된 데이터(숫자, 날짜, 키워드 등)나 분석되지 않은 텍스트 필드에 대해 사용합니다. term 쿼리는 입력된 값을 그대로 사용하여 일치하는 문서를 검색합니다. 이 쿼리는 주로 필드가 keyword 타입일 때 많이 사용됩니다.

2. match 쿼리
match 쿼리는 전체 텍스트 검색을 위해 사용됩니다. 이는 분석된 텍스트 필드에 대해 주로 사용되며, 텍스트를 분석기(analyzer)를 통해 토큰화하고 검색합니다. match 쿼리는 입력된 텍스트를 분석하고, 분석된 토큰들 중에서 일치하는 문서를 찾습니다. 이 쿼리는 주로 필드가 text 타입일 때 많이 사용됩니다.

주요 차이점 요약
타입: term 쿼리는 구조화된 데이터나 분석되지 않은 텍스트 필드에 사용되며, match 쿼리는 분석된 텍스트 필드에 사용됩니다.
분석: term 쿼리는 입력된 값을 그대로 사용하며, match 쿼리는 입력된 텍스트를 분석합니다.
대소문자: term 쿼리는 대소문자를 구분하지만, match 쿼리는 기본 분석기를 사용하는 경우 대소문자를 구분하지 않습니다.
용도: term 쿼리는 정밀한 값을 검색할 때 사용되고, match 쿼리는 부분 일치 텍스트 검색에 사용됩니다.


## Elasticsearch란 무엇인가요?
- JSON 도큐먼트를 저장하고 검색하는 검색엔진입니다. 텍스트검색, 데이터분석 등을 위해 사용하며, 루씬 기반으로

## ES 인덱스란?
- ES 인덱스 는 문서가 저장되는 단위이며, 각 인덱스는 여러개의 샤드로 분할되어 저장됨

## ES 에서 문서란
- JSON 형식 데이터 기본 단위, 각 문서는 특정 인덱스에 저장되며 고유ID 를 갖습니다

## ES 에서 맵핑이란
- 매핑은 인덱스 내에서 문서의 구조를 정의하는 과정

## ES 에서 샤드Shard 란?
- 인덱스 데이터를 분산 저장하는 기본 단위.
- 각각의 인덱스는 여러개의 주 샤드(primary shard)와 복제 샤드(replica shard)로 나뉘어 저장

## ES 에서 노드, 클러스터 란?
- 노드= 컴퓨터 한대, 클러스터= 노드묶음

## ES 에서 쿼리(Query)와 필터(Filter)의 차이 란?
- 쿼리는 검색의 적합성을 기반으로 문서를 찾는 과정이고, 필터는 이진 판단을 통해 문서를 포함하거나 제외하는 과정입니다. 필터는 캐시되어 더 효율적

## ES 에서 term 쿼리와 match 쿼리의 차이점은 무엇인가요?
- term 쿼리는 정확한 용어와 일치하는 문서를 찾고, 분석을 거치지 않습니다. 
- match 쿼리는 텍스트를 분석하여, 토큰화된 용어와 일치하는 문서를 찾습니다.

## mysql 샤드와 파티셔닝 차이
- 샤딩 : 스케일아웃을 위해 용량과 성능 확장
- 파티셔닝 : 단일 테이블 성능 최적