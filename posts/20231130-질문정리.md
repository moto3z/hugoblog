---
title: "20231130 질문정리"
date: 2023-11-30T19:11:23+09:00
draft: true
---

## 예상질문

### RDBMS 관

- 슬로우/더티쿼리 : 느린쿼리, 예를들어서 테이블 풀스캔이 나는 쿼리, 라이크 쿼리에 키워드 앞뒤로 % 가 붙는 쿼리를 의미합니다
- 악성쿼리 : 클라이언트가 입력한 데이터를 서버에서 필터링, 이스케이핑을 해야함, 에러페이지를 표시하지 않고, 서버검증을 꼭 한다. (SQLi)
- ER-D 란? 엔티티 릴레이션 다이어그램, 데이터를 모델링한것인데, 시스템, 비지니스 프로세스 에 사용되는 데이터들과 그 관계들에 대해서 표현
- 데이터베이스 설계 원칙
  - 정규화란 RDBMS 에서 데이터를 중복없이 저장하기 위한 프로세스
  - 1정규화 : 한칸에는 데이터 하나만
  - 2정규화 : 현제 테이블의 주제와는 관련없는 컬럼을 다른 테이블로 빼는 작업(파셜 디펜던시의 제거)
  - 3정규화 : 특정 컬럼에 종속된 컬럼은 다른 테이블로 분리해내기
- 아이솔레이션 레벨
  - READ UNCOMMITTED : 커밋이나 롤백에 상관없이 다른 트랜잭션에서 데이터가 보임, 정합성 문제가 있을수 있음 (표준 격리수준아님!)
  - READ UNCOMMITTED : 변경 내용이 COMMIT 되어야만 다른 트랜잭션에서 조회 가능, NON-REPETABLE READ 문제 발생 (다른 트랜잭션 입장에서, 데이터를 똑같은걸 두번 조회했는데 다른 결과가 발생할 수 있다는것)
  - REPETABLE READ : 같은 트랜잭션 내에서는 같은 값이 조회되도록 보장해주는 격리수준, Phantom READ 문제가 있음 (같은 쿼리를 두번 조회했는데, 처음에는 없던 레코드가 두번쨰에서 나타나는 증상)
- 데이터베이스 락(비관적pessimistic / 낙관적optimistic )
  - pessimistic lock : 충돌이 일어난다고 가정하고 락을 거는 방식, 트랜잭션이 시작될 때 Shared Lock 또는 Exclusive Lock을 걸고 시작해서 데이터 충돌을 예방하는 방식.
  - JPA 에서 LockModeType 옵션이 있음, 비관적락은 데드락 발생가능성이 있고 동시처리 성능이 저하된다. 낙관적 락은 충돌

- acid 원칙 : 트랜잭션을 정의하는 4가지 원칙입니다. Atomicity(원자성), Consistency(일관성), Isolation(격리성), Durability(영속성)
- 인덱스 : 테이블에서 write 성능을 희생하고 read 성능을 높이는 자료구조이며, b-tree 알고리즘을 사용합니다.
- 클러스터드 인덱스 : MySQL의 innoDB 엔진에서는 primary key 순서로 레코드들이 물리적으로 정렬되어서 저장되어 있는데, 이를 클러스터드 인덱스라고 합니다
- (RDB) 카디널리티 : Cardinality 는 특정 데이터 집합의 유니크(Unique)한 값의 개수, 중복도의 반대되는 개념
  - 1,1,1,1,1 : 카디널리티는 낮고, 중복도는 높다
  - 1,2,3,4,5 : 카디널리티는 높고, 중복도는 낮다
- (RDB) 복합키 인덱스에서, 복합키 인덱스의 순서
  - 카디널리틱다 큰 순서대로 (유니크한게 많은 컬럼이 먼저!)
- 데이터베이스 성능최적화란? : RDBMS 최적화는 한마디로 Disk FILE I/O 를 최대한 줄이는것이다.
  - 커버링인덱스로 메모리의 인덱스만 가지고 쿼리를 충족한다던지
  - 카디널리티가 높은 컬럼에 인덱스를 태워서 필요한 데이터만 가져온다던지
- 커버링인덱스 : 쿼리를 수행하는데 필요한 모든 데이터가 메모리상의 인덱스에 존재해서, 파일IO로 접근해야하는 리프노드에 접근하지 않고도 쿼리결과를 리턴할수 있는 경우가 커버링인덱스
- 복합 인덱스란 : 데이터베이스에서 여러 개의 컬럼(열)들을 조합하여 인덱스를 생성하는 것
- 복합인덱스 순서 : 카디널리티가 큰 (=중복도가 낮은) 순서대로 구성하기

## JPA

- 엔티티 라이프사이클 : 비영속(객체생성만) - 영속(저장, 트랜잭션 커밋시점) - 준영속(컨텍스트 detach) - 삭제
- 영속성 컨텍스트: 엔티티를 영구 저장하는 환경인데, 트랜잭션마다 하나씩 생기
- 1차캐시 : 영속성 컨텍스트 내부에 엔티티를 보관하는 저장소가 있는데 이것을 1차캐시라고 하고 영속성 컨텍스트 내부 범위에서의 캐시
- 2차캐시 : 어플리케이선 레벨의 캐시, 레디스같은 외부 저장소를 쓸수도 있는데 어플리케이션 범위의 JPA 캐시가 2차캐시임. 기본은 사용안함
  - JPA 쿼리시 1차캐쉬 찾아보고 - 2차캐시 찾아보고 - 없으면 그때 RDBMS에 Select~ 날림
- 영속성 컨텍스트의 기능 (5가지)
  - 1차캐시, 동일성 보장, 트랜잭션쓰기지연, 더티체킹, 레이지 로딩
- 트랜잭션은 어떻게 구현하나요?
  - AOP 기반으로 프록시객체를 이용해서 StartTX / commit or rollback 을 메인로직 앞뒤로 끼워넣어서 동작합니다
- @Transactional 사용시 주의사항
  - 1. private method 에 사용할 수 없음
  - 2. 서로 다른 @Transactional method 는 서로를 호출해서 사용할 수 없음
- N+1 문제가
- ORM이란? 오브젝트 릴레이션 맵핑의 약자로써 자바의 객체와 RDBMS 의 레코드 하나를 매핑 해주는 기술입니다.
- (JPA) OSIV : JPA 에서 영속성 컨텍스트를 뷰까지 열어두는 기능. 쉽게말해서 트랜잭션이 service, repo layer 에만 있는거 아니라, controller 레이어까지 걸쳐 있다 기본값으로 ON (Open Session In View)
  - 장점은 , B2B 서비스에서 좋은데, 사용자가 적은 환경에서는 영속성 컨텍스트가 빠르게 열리고 불필요한 영.컨의 open/close 가 적기때문에 성능이나 응답속도가 개선된다
  - 단점은 , B2C 서비스에서 안좋은데, 사용자가 많으면 영속성컨텍스트가 열리는게 DB 커넥션풀을 하나 여는것이기 때문에 사용자가 많은 배민같은 서비스에서 osiv on 하면 커넥션풀이 말라버리기 때문에(커넥션이 부족해져서) 사용자가 많은 서비스는 서비스는 적용하기 어렵다

## 스프링 프레임워크

- 스프링에 대해서 이야기해주세요 : 자바기반의 OOP 웹 프레임워크입니다. 핵심기술로는 DI, 벨리데이션과 바인딩, 데이터 엑세스와 트랜잭선, AOP 등의 기능이 있습니다.
- 커넥션 풀 갯수는 어떻게 최적화 하나요? : 쓰래드풀 수 _ 쓰레드당 필요한 커넥션 수 _ 배수 (디폴트 10, 맥스 200 으로 알고있습니다). 자바에서는 히카리CP 를 기본 데이터소스로 사용중임
- 쓰레드 풀 숫자는 어떻게 최적화 하나요? : CPU 코어 갯수 \* 2 정도로 지정하는게 좋을꺼같습니다.
- SOLID 원칙이란 : 객체 지향 디자인 원칙, 유지보수하기 좋고 유연하게 확장 가능한 소프트웨어를 만들기 위해서 필요합니다. SRP, OCP, LSP, ISP, DIP
- DI : 객채간 의존성을, 내부에서 직접 생성자를 호출하지 않고, 외부에서 주입받는 디자인 패턴입니다.
  - 외부에서 객체간 관계 설정시, 클래스 레벨의 의존이 아니라 인터페이스 레벨로 의존하여서 메시지를 주고받음으로써 계층간 결합을 느슨하게 합니다.
- AOP : 스프링 프레임워크의 기능 중 하나로, 핵심 비즈니스 로직과 부가 기능(횡단 관심사, cross-cutting concerns)을 분리하여 모듈화할 수 있게 해줍니다
- 필터, 인터셉터, AOP 차이점 : 셋 모두 소프트웨어에서 횡단관심사(크로스컷)을 처리하기 위한 방식인데요, 목적과 사용방식에 차이가 있습니다.
  - 필터는 HTTP 요청과 응답을 주고받는데 사용되며, CORS 토큰처리 등에 사용됩니다
  - 인터셉터는 프레임워크 기능, AOP 는 핵심로직이 아닌 부가적인 로직(로깅추가, 예외처리, 트랜잭션 롤백) 등의 횡단 관심사를 모듈화하는데 사용
  - 인터셉터는 HTTP 요청과 응답을 가로채기 위해 사용되며 특정 URL 패턴에 대한 요청을 처리하기 전에 전처리 작업을 수행하거나, 후처리 작업을 수행합니다.
  - Spring MVC에서 HandlerInterceptor 인터페이스를 구현하여 사용
- AOP 는 핵심 비즈니스 로직과는 별도로 관심사(횡단 관심사, Cross-cutting Concerns)를 분리하여 모듈화하는 데 사용
  - Aspect, Advice, Join Point, Pointcut 등의 개념을 사용하여 동작하고 Before, After, Around 등에 코드 실행
- REST API 란 웹 서비스를위한 소프트웨어 아키텍쳐 스타일 "어떻게 http프로토콜로 정보를 제공할 것인가 에 대한 답"
  - self-decriptive : 메시지는 스스로 설명해야한다 헤더와 바디 모두
  - hateoas : app 의 상태는 하이퍼링크를 이용해 전이되어야한다
  - indiviual-evolution : 프론트와 백엔드, 웹브라우저 모두 독립적으로 진화 가능해야 한다




### 와일드카드

- 어떤 방식으로 협업하시나요?
  - 짧은주기로 자주 소통합니다.
  - 업무에 방해가 되지 않도록 async 방식으로 주로 소통합니다
  - 하는일의 목적의식을 가지고 일하면서 적극적으로 의견을 구하고 피드백을 받습니다.
- 앞으로 뭘 하고싶으신가요?
  - 누군가가 정말 필요로하는, 세상에 도움이 되면서 동시에 회사에 영업이익을 플러스 시켜줄수 있는 프로젝트에 참여하고싶습니다.
  - 프로젝트를 서비스/프로덕트로 만들어 실제로 동작하게 만드는 과정 속에서 스스로의 노력 과 동료들과의 협업 그리고 피드백을 통해서 기술적으로도 한단계 성장하지만, 인간적으로도 한단계 성장하고 싶습니다
  - 더 욕심을 내보자면 주도적으로 이슈를 해결하고, 발굴해내고, 제가 아는것을 공유하고 모르는것을 인정하고 받아들이면서 동료들에게 영감과 용기를 주는 사람이 된다면 정말 영광일꺼같습니다.
- 조직에 어떤것을 기대하시나요?
  - 기술적 : 중요한 비지니스 로직을 단위테스트로 검증할수 있는 구조, 테스트코드, 코드리뷰 문화, 빠르게 요구사항을 수용할수 있는 지속가능한 코드
  - 협업과 커뮤니케이션 문화 : 자유로운 의견 교환, 건설적인 피드백, 목적의식 있는 업무진행
- 카프카 : 메시지 브로커, 빠른 쓰기속도를 가지고 있다. 생산자-소비자 패턴의 대표적인 사례
- 인버티드 인덱스 (es) : 어떤 내용과 그것의 위치를 매핑한 자료구조로 해시맵과 비슷하다. 가령 '맛집'이라는 단어가 포함된 문서/웹페이지의 위치를 알려주는 것 // 인덱스는 번호 위치가 있으면 거기에 있는 데이터가 뭔지를 빨리 알려주는건데, 그 반대라서 인버티드 인덱스
- 질문
  - 팀에서 협업과 커뮤니케이션은 어떤 방식으로 이루어지나요?
  - 20명 정도의 팀을 리딩하시면서, 개개인의 역량이나 성과를 어떻게 파악하고 어떤 기준으로 평가하시는지 궁금합니다
  - 프로젝트를 진행하면서 어떻게 일정을 관리하시는지, 일정지연이나 이슈에는 어떻게 대응하시는지, 업무 우선순위는 어떻게 결정하시는지 궁금합니다

## RNR 정리

- 10X를 추구합니다 : 혼자 잘하기보다 다같이 일을 잘 할수 있도록 노력하는 사람

  - 불필요한 코드를 지우는사람
  - 데이터 구조를 코드로 관리하는사람
  - 도메인 지식을 문서로 남기고 코드로 녹이기 위해 노력하는사람
  - 문서로 아는것을 나누기 위해 노력하는 사람
  - 구조적인 개선을 위해 노력하는 사람 $N^2$ -> $nLogN$ 으로 바꾸기 위해 노력하는사람

- 꿀팁 $~~$ : 레이텍스 >> 달러두개는 한줄,

> > 인조잔디인지, 천연잔디인지 << 인조잔디가 하도 많아서

- 공개소스나, 깃헙레포가 있는지

## 한일들 - 솔루션

- Wonderland OMS 프로젝트

  - OMS 개발지원
    - 사례1 : 간헐적인 HTTP 500 error 트러블슈팅 > skillbuilder 저장용량 & 메모리 부족이슈 원인 파악하여 용량증설
    - 사례2 : JenkinsBatch 에서 Spring-Domain LOG 가 보이지 않는 이슈 해결 : logback config 수정
    - 사례3 : 관계형데이터베이스 DDL, DML 버전 관리
    - 사례4 : 공통-OMS 마스터 데이터 연동 SAGA 개발 : Grpc, Kafka 사용
  - 성능테스트
    - 서버 리소스 (pod Count, Memory Size) 에 따른 성능 변화 확인
    - pod count 가 2,4,6,8 변함에 따라 성능에 어떤 영향을 미치는지 확인한 결과 pod 수는 4개로 충분함을 확인함
    - MySQL Spec 에 따른 성능 변화 확인 & 목표 TPS 달성을 위한 인프라 스펙 산출 DB Spec Class(cpu+memory) 변화에 따른 성능을 산출하고 목표 TPS 도달을 위한 필요스팩을 "데이터 기반으로 추세선을 파악하여 산출함"
  - 도메인 용어집 정리, OMS flow chart 정리 : DO, STO, TO, EO
  - 코드관리, git & branch 관리, conflict 해결

- Apollo OMS 프로젝트
  - 성능테스트
    - OMS 시스템에 대한 성능테스트를 진행
      - 시나리오에 따른 대상과 범위인 target API Endpoint 정리
      - 성능테스트 환경 구성 (by ngrinder) & script (groovy) 작성
      - API Endpoint 에 대한 RPS(Request Per Second) 를 산출하였습니다.
        - TODO : 정리하기 ngrinder 환경구성 & 샘플 스크립트 작성하는거 진행해야함
    - 성능테스트 보고서 등의 산출물을 공유하고 결과보고서 작성
    - tech stack : grafana(RDB, Backend 모니터링), nGrinder 사용
  - 아모레퍼시픽 프로젝트 성능테스트 진행
    - 주요 11개 API Endpoint (주문, 운송장, 실적 관련) 에 대한 성능테스트 진행
    - 성능테스트를위한 groovy script 작성, 성능테스트 실시, 성능테스트를 위한 전처리작업 (dataset정제, domain 조건) 진행
    - parameter를 변경하며 최적의 성능지점 확인, RDBMS Spec 변화, Pod 스펙 변화를 통해서 scale-up/scale-out 시 성능 변화 예측 insight
    - Http Request body 변인통제를 통한 최대 throughput 조건 도출
      - OMS 개발지원
    - SAGA 마스터연동 : HTTP, KAFKA

## 한일들 - 플랫폼

- 개인정보 보안로그

  - what : 개인정보 API 호출 History Logging 개발API
    - 접근에 대한 호출자 정보, 응답 개인정보 내용등을 저장
      - 호출자의 정보 : 이메일, LDAP 등..
      - 응답 개인정보 : row count, API endpoint, LogType 자동결정 기능
    - Log 에러방지기능, 필요이상으로 긴 data 들에 대한 validation 기능(email, IP주소 길이 제한)
  - why : 개인정보 보안 법령에 의거한 필수내용 & 사내 ISMS 인증을 위한 개인정보관리 거버넌스 달성
  - how : Spring AOP 기능을 이용해, CrossCut Point 분리하는 구조로 개발함. 이로 인해 Main 로직 변경점 없음으로 유지보수성과 가독성이 좋음

- LaasIAM 서비스 런칭

  - what : okta-auth0 IAM 서비스 런칭
    - auth0 IAM 사용 신규 cbt 클러스터 구축 (k8s, DB Mig 작업진행)
    - IAM 내 계정정보 OM/WM Sync Batch 개발
  - why : 사용하던 kep-iam 서비스 종료로 인한 대체 서비스 Migration

- 이외

  - 프리랜서 입사 & 퇴사 시스템 연결 : Access, git 이슈 해결
  - 보안검수 : 오픈리다이렉트 취약점, CORS, SSL-Offloading, SpringBoot & Vue2 취약점 버전업 대응
  - admin Frontend 유지보수 : VDI ON/OFF 기능 추가하여 개인정보관리 거버넌스 충족
  - 데이터 추출 (마케팅용, 회원관리용, 기획&Biz용 등등..)
  - multiversion in cluster : 한 클러스터 내 여러가지 버전의 OMS를 동작시키고 테스트 할 수 있는 기능 개발
    - OMS가 거대한 3개의 프로젝트(물류대행, 라스트마일, 솔루션프로젝트) 를 동시에 진행하여 테스트가 곤란한 문제를 해결
  - 인턴십 직원 Care 업무
    - Action Item List 기획, 실행, 중간점검 진행
      [Phase1] 로컬개발환경 문서화 (2주 : 04.13 ~ 04.25)
      [Phase2] API Docs (2주 : 04.25 ~ 05.10)
      [Phase3] 마스터 이행 구조도 (4주 05.11 ~ 06.08)
    - 면접 질문지 리스트업, 온보딩, 커피챗 진행
  - Dolphin 물류비 정산 관련 이슈 트러블슈팅
    - bulkinsert 관련 기능개발, 테스트코드 추가
  - OMS 개발지원
    - OMS App 공통백엔드 API
    - SKU 코드 최대길이 제한 변경 20->50
  - SpringBoot App 설정파일 k8s ConfigMap 이관 POC
  - LMD 모듈 화주사 Sync Saga 개발

- 신규 프로젝트 세팅
  - parrotfish 모듈 Gradle spring multimodule 셋팅
    - spring boot 버전 업그레이드 (2.3 -> 2.7)
  - prawn 모듈 Gradle spring multimodule 셋팅
    - JPA + Mybatis 동시사용
  - JDK & JVM Options 정비 & 일원화
  - KIC VM proxy 설정 일원화
  - Springboot 취약점 발견 버전업

### 셀프세차장리뷰
```
Strengths : 다양한 분야에 걸친 Laas부문의 프로덕션을 만들어가는데 혈액과 같은 역할로써 필요한 순간에 필요한 정보와 작업을 해내고싶습니다.
Weaknesses : 솔루션 프로젝트, 프로덕트 보완 등 여러가지 Phase 에서 중첩되어 들어오는 상황에서의 우선순위를 조금 더 잘 파악하고 해결해나가고싶습니다.
Opportunities : 적절한 퀄리티와 적절한 시간 내에 업무를 완성해 Work-life balance 를 찾아가는 시기라고 생각합니다.
Threats : 앞으로 주어진 혹은 조직에서 필요한 업무들을 주도적으로 발굴해서 해결하고 싶습니다.
```

### 작년

- 대용량 이미지 업로드 서버 개발(crab module)

  - Matching에 물류창고 VR 컨텐츠 제공을 위해서 컨텐츠 업로딩 서버가 별도로 필요하여 microservice 모듈 개발
  - 물류창고 VR 컨텐츠는 수십만장의 이미지 파일을 서로 concat 하여 이미지를 제공하므로 물류창고 하나에 평균 이미지 50K 개씩이 필요합니다

- DEV, CBT 향 신규 Kubernetes cluster 구축 (2022.02~2021.05)
  - Kakao i cloud 환경에서 신규 개발&스테이징 환경 인프라 구축
    - 데이터베이스 migration
    - redis, kafka,

## 썰 준비

- wms 는 바운디드 컨텍스트가 4개가 있습니다 : 입고, 출고, 프로덕트(SKU), 로케이션
- 조금더 근본적인것을 학습하고 체득하기 위해 노력합니다 OOP, 검증가능하고 지속가능한 코드, 테스트코드, 리팩토링, 아키텍쳐,
